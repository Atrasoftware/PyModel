
PyModel socket sample: modeling and testing with nondeterminism and concurrency

This sample uses network sockets to demonstrate several PyModel
techniques for modeling and testing systems that exhibit
nondeterminism, concurrency, and asynchrony.

To understand the discussion here, it might be helpful to read
these files in the notes directory: concepts.txt, models.txt,
composition.txt, and stepper.txt.


Motivation: sockets are nondetermistic and concurrent

Socket behavior can be more complicated than expected, because data
are buffered on each end, and may be transported through the network
at an irregular rate.  A call to send a message may block until space
becomes available in the buffers, and even then may accept only part
of the message.  A call to receive may block until data arrives in the
buffers, and even then may deliver only part of the message.  Multiple
calls to send and receive may be needed to transmit an entire message.
Nondeterminism arises from the unpredictable amount of data that is
sent or received in each call.  Concurrency arises from the
simultaneous, unsynchronized sending and receiving that add and remove
data at the two ends of the connection.  For more explanation, see:

 http://docs.python.org/howto/sockets.html
 http://pyvideo.org/video/885/through-the-ether-and-back-again-what-happens-to


Socket sample contents

The sample includes these modules:

- msocket: a model program for network sockets that can exhibit
  nondeterminism and concurrency.

- synchronous, deterministic, etc.: several scenario machines and
  configuration files that select particular behaviors of the model
  program.

- stepper, stepper_o, and stepper_a: three different steppers (also
  called test harnesses or adapters) that use the model program and
  scenarios to test actual sockets on localhost (via the Python
  standard library socket module).  Also, Sender.py, Receiver.py,
  etc.: other code for exercising the standard library socket module.

- socket_simulator and socket_simulator_a: two simulators that can
  optionally replace the Python standard library socket module in the
  steppers.  These simulators can be configured to demonstrate a great
  deal of nondeterminism and concurrency, even with small messages.

- test, test_viewer, test_stepper, test_msgsize, etc.: several test
  scripts that invoke various combinations of these modules.

- fsmpy/ and svg/ directories that contain finite state
  machine modules and graphics files generated by the test
  scripts from the msocket model and its scenarios and configurations.

In the following sections we discuss some of these modules in more detail.
As we go, we explain many techniques for using PyModel.


Socket model program: modeling nondeterminism and concurrency

The model program in the msocket module models *both* ends of the
connection.  One end of the connection is always the sender and the
other end is always the receiver: all send actions occur at one end
and all recv actions occur at the other.  Messages sent at one end can
be eventually received at the other.

This model program only models sending and receiving messages - it
does not model establishing or closing the connections.  Therefore it
does not include actions that model the socket library operations
open, bind, listen, accept, connect, or close.  To test a real
implementation, those operations must all be handled in the stepper
(see Stepper sections, below).


Nondeterminism

The model exhibits nondeterminism, like a real socket connection.  The
send operation may accept any (incomplete) segment of its message
input, and the recv operation may return any (incomplete) segment of
the accumulated message segments that have been accepted at the sender
end.  Multiple sends and receives might be needed to transmit an
entire message.  So send or recv might return different values and
update the state differently, even when called in the same state with
the same arguments --- this is the essence of nondeterminism.

In PyModel model programs, nondeterminism is implemented by enabling
conditions.  Each action (for example send_call) has a corresponding
enabling condition (for example send_call_enabled), a boolean function
of the action arguments and the model program state.  The action can
be called whenever the enabling condition is satisfied (returns True).
(If the model program has no explicit enabling condition for an
action, it is taken to be True always --- the action is always
enabled.).  A boolean function can be written to be satisfied by many
different combinations of values, so this provides a way to represent
nondeterminism easily.  PyModel may call the action with any one of
the combinations of arguments that satisfy the enabling condition in
the current state.  PyModel considers all satisfying combinations and
chooses one (at random, or optionally guided by a strategy defined by
the programmer).  

Usually the enabling condition can be satisfied by a large range of
argument values, but the actual argument values that are used must be
drawn from a *domain*, a collection defined by the programmer.  A
domain must be defined for each argument of each action.  The domain
might be a fixed collection that is defined when the model program is
written, or it might be a *state-dependent domain* computed from the
model program state each time an argument value is needed.  The
domains are defined separately from the enabling conditions, so they
provide a convenient way to restrict the potential nondeterminism
offered by the enabling conditions.  An enabling condition might
permit a large range of argument values, but the domain can limit it
to a few, or just one.

It is typical for the enabling conditions and domains to permit
several different actions to be enabled in a given state.  PyModel
chooses one of these actions (at random or according to a programmed
strategy).  In this way, a model program can exhibit nondeterminism
regarding which action is executed, not just which argument values are
used.

Enabling conditions and domains can also represent nondeterministic
outcomes from actions.  This is accomplished by coding each operation
(in this model, each function call in the implementation) as *two*
actions in the model program.  For example, the send function in the
implementation is represented by send_call and send_return actions in
the model program.  An action modeled in this style, where the start
and finish of the operation (here, the function call and its return)
are coded as two separate actions in the model, is called a *split
action*.  Both start and finish actions in a split action require an
enabling condition (if either is omitted, that part of the action is
considered to be enabled always).  Split actions never have return
values.  Instead, the return value (or values) of the modeled
operation are coded as arguments of the finish action.  So where the
implemention has n = c.send(msg) and msg = s.recv(bufsize), the model
has a split action with send_call(msg) then send_return(n), and
another split action with recv_call(bufsize) and recv_return(msg).
Therefore, nondeterministic action outcomes can be represented by
coding the enabling conditions and domains for the finish actions.
For example, PyModel can nondeterministically choose values for n (the
number of characters acceped by send) and msg (the message returned by
recv).  The enabling conditions for the finish actions are, in effect,
the postconditions for those operations --- which can be
nondeterministic, if the programmer desires.

(An alternative way to represent nondeterministic outcomes without
split actions would be to write code in the action body that generates
a collection of possible results, and then randomly chooses one.  But
it turns out to be more convenient, flexible, and general to represent
nondeterminism with split actions, enabling conditions, and domains.
This is the method that is recommended and supported by PyModel.  In
particular, the PyModel analyzer (the pma program) might overlook
nondeterminism that arises in action bodies -- it might omit some of
those nondeterministic outcomes from its analyses.)

Concurrency

The model exhibits concurrency, like a real socket connection.
PyModel represents concurrency by interleaving.  Send and receive
actions can interleave without synchronization at the two ends of the
connection.  Each end can send or receive while the other end is
blocked.  This is achieved by modeling both send and receive as *two*
distinct actions for the call and return: send_call and send_return,
and recv_call and recv_return.  For example, we might see a trace with
these actions:

 recv_call
 send_call
 send_return
 recv_return

At the beginning of this trace, nothing has been sent yet.  The
receiver calls recv and blocks, because there is nothing to receive -
the buffers are empty.  Then the sender sends a message and returns,
so the receiver can read the message and return.  Here the receiver is
blocked from recv_call through recv_return, but while it is blocked
the sender can still run.  PyModel can model and test this behavior.

In PyModel, concurrency and interleaving are represented by split
actions.  It is necessary to code split actions in order to model
concurrency where some operations can proceed while others are
blocked.  Behavior that is event-driven, that can occur at
upredictable times, especially where the end of an operation occurs at
some time after the beginning (with other actions occuring in the
meantime), is called *asynchronous* behavior.  Split actions are a way
to code asynchrony in PyModel.  

So split actions serve *two* functions in PyModel.  In addition to
representing nondeterminism (explained above), they also represent
concurrency with asynchronous behavior.


Restricting nondeterminism and concurrency

The msocket model program in this sample exhibits nondeterminism and
asynchronous behavior (blocking and interleaving send and recv).
However, these are rarely seen in the common situation where a socket
transmits small messages over a fast network -- usually the entire
message is transmitted in in a single pair of send/recv calls.  In
fact, our first stepper module only works correctly with runs that
exhibit this common (deterministic, synchronous) behavior; it
considers any nondeterminism to be a test failure, and it just waits
forever at the first blocking call (our other steppers, stepper_o and
stepper_a, relax these restrictions).  Therefore, sometimes we wish to
restrict the behavior of the model to deterministic, synchronous
behaviors.

In PyModel, concurrency and asychrony permitted by a model program can
be removed by scenario machines, and nondeterminism can be restricted
by domains.


Restricting concurrency: synchronous scenario

The *synchronous* module is a scenario machine, an FSM.  A graph of
this scenario appears in Socket/svg/synchronous_graph.svg (which you
can display in a browser).  As the graph shows, in this scenario
send_call is always immediately followed by send_return, and recv_call
is always immediately followed by recv_return.  Composing a model
program with a scenario has the effect of synchronizing them, so the
model program can only execute sequences of actions permitted by the
scenario.  Different scenarios can be written that select different
behaviors.  Here, composing the msocket model program with the
synchronous scenario machine has the effect of merging the two parts
of each split action into a single atomic (indivisible) action.  Once
send or recv is called, it always returns before another action can
begin - now the behavior is *synchronous*.  Moreover, in this scenario
one send is always followed by one recv - the behavior is
*sequential*.


Restricting nondeterminism: the nondetermistic configuration

In a model program, the enabling condition for an action might permit
a large range of argument values, but the domain for that action can
limit it to a few, or just one.  Different domains can be written that
select different collections of arguments.  The *deterministic* module
is PyModel configuration file that redefines the domains of
send_return and recv_return.  Here both are *state-dependent domains*.
Now send_return always accepts the entire argument of send_call (not
just a prefix, as specified in its enabling condition), and
recv_return always produces the entire buffer contents (not just a
prefix).  This has the effect of deterministically transmitting the
entire message from sender to receiver in a single pair of send/recv
calls.


The test script

The test module generates some samples of behavior that demonstrate
the msocket model program and the effects of the synchronous scenario
and deterministic configuration.

The test module is a test script that contains test cases that run
pmt, the PyModel tester.  The pmt command generates *traces* (test
runs), which are simply sequences of actions (function calls).  The
pmt command can optionally execute and check the test runs it
generates, but here we just generate the traces to get samples of
behavior to examine.  For this, we do not need a stepper (test
harness) because we do not need to connect the model to any socket
implementation.

To run the script and see the traces, type this command at
the system shell prompt: trun test

The first test case executes this command: pmt -n 10 -c 6 msocket (you
can also type this command yourself).  It generates a short (10 to 16
step) trace from the msocket module alone, so the trace may exhibit
nondeterminism and asynchrony, with interleaving send and recv and
incompletely sent messages.  The messages (arguments to send_call) are
limited to 'a' and 'bb' by the domain in the msocket module.  This
command chooses actions and their arguments at random so repeating the
command generates different traces (to make runs repeatable, set the
random seed with the -s option).  To see longer traces, use a larger
-n option.  Omit the cleanup option -c to generate exactly -n steps,
which may stop in a non-accepting state (with a call in progress or a
message in flight).

The second test case executes: pmt -n 10 -c 6 synchronous msocket.
Including both the model program and a scenario machine as command
arguments forms their composition.  Now the run exhibits synchronous
behavior: each call is immediately followed by its return.  There is
no more blocking, no more interleaving of send and receive.  Moreover,
send and receive alternate, as dictated by the scenario machine.  But
the behavior may still be nondeterministic - incomplete messages may
be sent.

The third test case executes: pmt -n 10 -c 6 deterministic synchronous
socket. The also includes the deterministic module, the configuration
file that reassigns domains to ensure that the entire message is always
sent and received immediately.  


The test_viewer script

The test_viewer module generates graphs that illustrate the behavior
of the msocket model program and the effects of the synchronous
scenario and deterministic configuration.  To generate the graphs,
type this command: trun test_viewer

The test_viewer module is a test script that runs pmv, the PyModel
viewer.  The pmv program in turn invokes pma, the PyModel analyzer,
and pmg, the PyModel graphics program, and dot, a rendering program.
The pma program performs an analysis called *exploration* which
generates a finite state machine (FSM) from the model, and pmg
generates a file of graphics commands in the dot language from the
FSM.  Finally, the dot program renders the output of pmg in a chosen
graphics format.  This script generates .svg files, which you can view
in a browser. (Older versions of IE did not display .svg files - has
MS fixed this?).

The test_viewer module generates four .svg files, which are in the
Socket/svg directory:

socketFSM.svg is generated by the command: pmv msocket.  It shows a
graph of an FSM generated by exploring the msocket model program.
Every node in the graph represents a program state (hover the cursor
over a node to show the state variables and their values).  Every edge
in the graph represents an action (every edge is labeled with the
function call including its argument).  Every path through this FSM
describes a trace that the model can execute --- runs generated by the
first test case in the test module are examples.  Multiple edges
emerging from a node indicate nondeterminism, and every _call edge not
immediately followed by a _return edge indicates asynchrony.

synchronous_graph.svg is generated by the command: pmv -o
synchronous_graph synchronous.  It is the graph of the synchronous
scenario machine, an FSM.

synchronousFSM.svg is generated by the command: pmv synchronous
socket.  It is a graph of the msocket model program composed with the
synchronous scenario machine.  Paths through this FSM include the runs
generated by the second test case in the test module.  Notice that
every call is followed by return, and every send is followed by receive.
But, there is still nondeterminism in action arguments.

deterministicFSM.svg is generated by the command: pmv deterministic
synchronous msocket.  It is a graph of the msocket model program
composed with the synchronous scenario machine, using the domains in
the deterministic module.


The stepper test harness

The stepper module is a test harness (sometimes called an adapter)
that connects a socket model (the mstepper module etc.) to a socket
implementation (usually the Python standard library socket module).
The stepper enables the PyModel tester pmt to use a model to 
call methods in the implementation and check the results.

This stepper handles *both* ends of the socket connection so it can
test both send and recv (recall that the model program msocket always
sends at one end of the connection and receives at the other).  And,
it does this in a single ordinary process (Python program invocation)
on the local machine.  It accomplishes this by connecting to both ends
of a socket on localhost and alternating calls to send and recv.

This stepper has serious limitations.  It cannot handle nondeterminism
nor asynchrony.  This stepper expects that the connection will always
accept the entire message passed to send and then return immediately.
It expects that the next call to recv at the other end of the
connection will return the entire message immediately.  Any other
behaviors are considered test failures.  These are serious limitations
but this stepper often works well enough, because real sockets usually
behave this way when when small messages are sent across a fast
network.  

This stepper is included to show how a basic stepper that supports a
useful subset of behaviors can be written easily.  Below we will
discuss stepper_o and stepper_a, that support all model behaviors
correctly.


The test_stepper script

The test_stepper module is a test script with three test cases that
reveal some of the limitations of this stepper.  To run these tests,
type the command: trun test_stepper.  None of the test
cases in this script uses the -s option to set the random seed, so
repeating this command will result in different test runs.

The first test case runs this command: pmt.py -n 10 -c 6 msocket -i
stepper.  In this test case model behavior is not restricted by any
scenario machine, so _call actions are not always followed immediately
by _return actions.  However, the test does not block because this
stepper does not call the socket implementation until the _return
action appears in the trace.  This test case does not use any
configuration modules to limit nondeterminism, so recv often returns
only part of the message provided by send.  But with messages this
small, the implementation usually returns the entire message - so the
behaviors of the model and the implementation differ, even though both
are correct.  This is the essence of nondeterminism: different
behaviors can all be correct.  But this stepper does not handle
nondeterminism, so any differences between the behaviors of the model
and the implementation are reported as test failures.  So usually this
test case fails, due to limitations in the stepper, not errors in the
model or the implementation.  The next two test cases attempt to remedy
this by limiting the behavior of the model.

The second test case runs this command: pmt.py -n 10 -c 6 msocket
synchronous -i stepper.  This command composes the msocket model with
the synchronous scenario, so it generates test runs where _call is
always immediately followed by _return.  However it does not limit
nondeterminism so usually this test case fails due to limitations
of this stepper.

The third and final test case runs this command: pmt.py -n 10 -c 6
msocket deterministic synchronous -i stepper.  This limits the model
to behaviors that are synchronous (_call is always immediately
followed by _return) and deterministic (the entire message sent is
always immediately received).  Now the model satisfies all the
assumptions of this stepper.  Moreover, with messages this small (they
are defined by the domains in the mstepper and deterministic modules),
the implementation is also synchronous and deterministic.  Therefore
the model and implementation behave exactly the same, so these test runs 
succeed.  


The msgsizes test suite

The msgsizes module is a test suite that investigates how socket
behavior depends on message size.

Recall that our stepper assumes that socket behavior is synchronous
and deterministic.  We observe that this assumption is usually
satisfied when sending small messages.  How large a message does it
take to break this assumption?  The msgsizes module contains a test
suite (a collection of test runs) with increasingly larger messages,
to find how large a message must be so it is no longer completely
transmitted by one send.  When that happens, the test will fail.  The
message sizes range from 8192 characters (8K) up to 1024K (1M).

The first two test runs in this suite are intended to fail - the sent
message and the received message differ by one character (as if that
character had been corrupted during transmission).  This behavior is
not permitted by the model.  The last test run in this suite is
expected to fail with this stepper, because only part of the sent
message is received.  


The test_analyze_msgsize script

The test_analyze_msgsize module is a test script that uses the PyModel
analyzer pma to check the test suite in the msgsizes module.  It
checks that the first two runs violate the msocket model, and all the
rest satisfy it.  Composing a test suite with a model is the usual way
to check that that the runs in the test suite are allowed by the model.
This can be used to validate either the test suite or the model
(depending on which is more trusted).  Here we are using it to
validate the msgsizes test suite.

This script contains one test case, that runs this command:

 pmv -o msgsizesFSM msgsizes msocket all_observables -l name -xy

Recall that the PyModel viewer pmv invokes the analyzer pma and the
graphics programs pmg and dot.  This command forms the composition of
msgsizes and msocket.  The all_observables module declares that all
actions in the model are observable actions.  In this context, that
means that the analyzer pma uses the action arguments in the test
suite and ignores the arguments defined in the domains in the model
program.  (The -l and -xy options reduce clutter in the generated
graphics.)

Running the test script (type: trun test_analyze msgsize) generates
msgsizesFSM.svg, which you can display in a browser.  It shows a graph
of every test run in the suite.  As intended, the first two runs are
not permitted by the model.  The graph of each of these two runs does
not include the final recv_return action, which is forbidden because
its message argument violates the model --- each contains one
erroneous character that differs from the message passed to send_call.
The final state in these runs is colored yellow because it is not an
accepting state (because it does not reach the final state of the run
in the test suite).  As intended, all of the other runs are permitted
by the model.  The final state in all runs (but the last) is colored
green, because it is an accepting state (it reaches the final state of
the run in the test suite).  The final state in the last run is
colored yellow.  It reaches the final state in the test suite, but it
is not an accepting state in the model (because part of the message is
still in transit - but this is intended here).


The test_msgsize script

Now that we have validated the test suite, we can execute it.  The
test_msgsize script is a test script that uses the PyModel tester pmt
to execute the runs in the msgsizes test suite with the Python
standard library socket module, with the aid of the stepper test
harness.

Execute the test suite: trun test_msgsize.  The first two runs fail,
as they should, because the test suite claims that the receive message
will contain an erroneous character, but the message actually received
by the real socket is a perfect copy of the sent message.  The next
runs, with larger and larger messages, all succeed.  Finally the
message becomes too large to send all of it in a single call and that
test case fails.  On my system (MacBook Pro, Mac OS X 10.7.5) it fails
on run number 9 (the tenth run), where the message size reaches 1
megabyte! (The failure is a timeout, indicating that the real socket
send call blocked).

The final call also fails, because the run in the test suite receives
only part of the message that was sent.  This behavior is permitted by
the model, but the real socket receives the entire message.  This
stepper considers any difference between the test suite and the
implementation to be a test failure.


The stepper_o observable stepper module

This stepper_o module supports nondeterminism. ...


The stepper_a asynchronous stepper module

The stepper_a module supports nondeterminism and asynchrony ...


The socket_simulator module


The socket_simulator_a asynchronous simulator module








