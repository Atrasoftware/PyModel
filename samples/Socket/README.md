
PyModel socket sample: modeling and testing with nondeterminism and concurrency
===============================================================================

This sample uses network sockets to demonstrate several PyModel
techniques for modeling and testing systems that exhibit
nondeterminism, concurrency, and asynchrony.

To understand the discussion here, it might be helpful to read
these files in the `notes` directory: `concepts.txt`, `models.txt`,
`composition.txt`, and `stepper.txt`.


Motivation: sockets are nondetermistic and concurrent
-----------------------------------------------------

Socket behavior can be more complicated than expected, because data
are buffered on each end, and may be transported through the network
at an irregular rate.  A call to send a message may block until space
becomes available in the buffers, and even then may accept only part
of the message.  A call to receive may block until data arrives in the
buffers, and even then may deliver only part of the message.  Multiple
calls to send and receive may be needed to transmit an entire message.
Nondeterminism arises from the unpredictable amount of data that is
sent or received in each call.  Concurrency arises from the
simultaneous, unsynchronized sending and receiving that add and remove
data at the two ends of the connection.  For more explanation, see:

 http://docs.python.org/howto/sockets.html
 http://pyvideo.org/video/885/through-the-ether-and-back-again-what-happens-to


Socket sample contents
----------------------

The sample includes several modules.  In this README we discuss these:

- `msocket`: a model program for network sockets that can exhibit
  nondeterminism and concurrency.

- `synchronous`, `deterministic`: a scenario machine and a configuration
  file that optionally select particular behaviors of the `msocket`
  model program.

- `stepper`: a PyModel stepper (also called a test harness or adapter)
  that uses the `msocket` model program (and optionally, scenarios and
  configurations) to test actual sockets on `localhost` (via the Python
  standard library socket module).  Also, `stepper_util`, code used by
  the stepper.

- `observables`: a configuration file used with the stepper to indicate
  which actions in the `msocket` model program it should consider
  observable (the remaining actions are considered controllable).

- `test`, `test_viewer`, `test_stepper`: test scripts that invoke various
  combinations of these modules.

- `socket_simulator` and `select_simulator`: simulators that can
  optionally replace the Python standard library `socket` and `select`
  modules in the steppers.  The simulators can be configured to
  demonstrate a great deal of nondeterminism and concurrency, even
  with small messages.

- fsmpy/ and svg/ directories that contain finite state machine
  modules and graphics files generated by the test scripts from the
  `msocket` model and its scenarios and configurations.

In the following sections we discuss some of these modules in more
detail.  As we go, we explain some techniques for using PyModel.  In
addition to these modules, this sample contains several others that
were written in the course of developing this sample, that demonstrate
some techniques not discussed here.  They are explained in the file
`experiments.txt`.

Socket model program: modeling nondeterminism and concurrency
-------------------------------------------------------------

The model program in the `msocket` module models *both* ends of the
connection.  One end of the connection is always the sender and the
other end is always the receiver: all send actions occur at one end
and all `recv` actions occur at the other.  Messages sent at one end can
be eventually received at the other.

This model program only models sending and receiving messages - it
does not model establishing or closing the connections.  Therefore it
does not include actions that model the socket library operations
`open`, `bind`, `listen`, `accept`, `connect`, or `close`.  To test a real
implementation, those operations must all be handled in the steppers
(see Stepper sections, below).


Nondeterminism
--------------

The model exhibits nondeterminism, like a real socket connection.  The
`send` operation may accept any (incomplete) segment of its message
input, and the `recv` operation may return any (incomplete) segment of
the accumulated message segments that have been accepted at the sender
end.  Multiple `send`s and receives might be needed to transmit an
entire message.  So `send` or `recv` might return different values and
update the state differently, even when called in the same state with
the same arguments --- this is the essence of nondeterminism.

In PyModel model programs, nondeterminism is implemented by enabling
conditions.  Each action (for example `send_call`) has a corresponding
enabling condition (for example `send_call_enabled`), a boolean function
of the action arguments and the model program state.  The action can
be called whenever the enabling condition is satisfied (returns True).
(If the model program has no explicit enabling condition for an
action, it is taken to be True always --- the action is always
enabled.).  A boolean function can be written to be satisfied by many
different combinations of values, so this provides a way to represent
nondeterminism easily.  PyModel may call the action with any one of
the combinations of arguments that satisfy the enabling condition in
the current state.  PyModel considers all satisfying combinations and
chooses one (at random, or optionally guided by a strategy defined by
the programmer).  

Usually the enabling condition can be satisfied by a large range of
argument values, but the actual argument values that are used must be
drawn from a *domain*, a collection defined by the programmer.  A
domain must be defined for each argument of each action.  The domain
might be a fixed collection that is defined when the model program is
written, or it might be a *state-dependent domain* computed from the
model program state each time an argument value is needed.  The
domains are defined separately from the enabling conditions, so they
provide a convenient way to restrict the potential nondeterminism
offered by the enabling conditions.  An enabling condition might
permit a large range of argument values, but the domain can limit it
to a few, or just one.

It is typical for the enabling conditions and domains to permit
several different actions to be enabled in a given state.  PyModel
chooses one of these actions (at random or according to a programmed
strategy).  In this way, a model program can exhibit nondeterminism
regarding which action is executed, not just which argument values are
used.

Enabling conditions and domains can also represent nondeterministic
outcomes from actions.  This is accomplished by coding each operation
(in this model, each function call in the implementation) as *two*
actions in the model program.  For example, the `send` function in the
implementation is represented by `send_call` and `send_return` actions in
the model program.  An action modeled in this style, where the start
and finish of the operation (here, the function call and its return)
are coded as two separate actions in the model, is called a *split
action*.  Both start and finish actions in a split action require an
enabling condition (if either is omitted, that part of the action is
considered to be enabled always).  Split actions never have return
values.  Instead, the return value (or values) of the modeled
operation are coded as arguments of the finish action.  So where the
implemention has `n = c.send(msg)` and `msg = s.recv(bufsize)`, the model
has a split action with `send_call(msg)` then `send_return(n)`, and
another split action with `recv_call(bufsize)` and `recv_return(msg)`.
Therefore, nondeterministic action outcomes can be represented by
coding the enabling conditions and domains for the finish actions.
For example, PyModel can nondeterministically choose values for `n` (the
number of characters acceped by `send`) and `msg` (the message returned by
`recv`).  The enabling conditions for the finish actions are, in effect,
the postconditions for those operations --- which can be
nondeterministic, if the programmer desires.

(An alternative way to represent nondeterministic outcomes without
split actions would be to write code in the action body that generates
a collection of possible results, and then randomly chooses one.  But
it turns out to be more convenient, flexible, and general to represent
nondeterminism with split actions, enabling conditions, and domains.
This is the method that is recommended and supported by PyModel.  In
particular, the PyModel analyzer (the `pma` program) might overlook
nondeterminism that arises in action bodies -- it might omit some of
those nondeterministic outcomes from its analyses.)

Concurrency
-----------

The model exhibits concurrency, like a real socket connection.
PyModel represents concurrency by interleaving.  Send and receive
actions can interleave without synchronization at the two ends of the
connection.  Each end can send or receive while the other end is
blocked.  Once again, this is achieved by modeling both send and
receive as split actions: *two* distinct actions for the call and
return: `send_call` and `send_return`, and `recv_call` and `recv_return`.  For
example, we might see a trace with these actions:

 recv_call
 send_call
 send_return
 recv_return

At the beginning of this trace, nothing has been sent yet.  The
receiver calls `recv` and blocks, because there is nothing to receive -
the buffers are empty.  Then the sender sends a message and returns,
so the receiver can read the message and return.  Here the receiver is
blocked from `recv_call` through `recv_return`, but while it is blocked
the sender can still run.  PyModel can model and test this behavior.

In PyModel, concurrency and interleaving are represented by split
actions.  It is necessary to code split actions in order to model
concurrency where some operations can proceed while others are
blocked.  Behavior that is event-driven, that can occur at
upredictable times, especially where the end of an operation occurs at
some time after the beginning (with other actions occuring in the
meantime), is called *asynchronous* behavior.  Split actions are a way
to code asynchrony in PyModel.  

So split actions serve *two* functions in PyModel.  In addition to
representing nondeterminism (explained above), they also represent
concurrency with asynchronous behavior.


Restricting nondeterminism and concurrency
------------------------------------------

The `msocket` model program in this sample exhibits nondeterminism and
asynchronous behavior (blocking and interleaving `send` and `recv`).
However, these are rarely seen in the common situation where a socket
transmits small messages over a fast network -- usually the entire
message is transmitted in a single pair of `send`/`recv` calls.  In fact,
the first stepper we wrote, `stepper_d`, only works correctly with runs
that exhibit this common (deterministic, synchronous) behavior; it
considers any nondeterminism to be a test failure, and it just waits
forever at the first blocking call (our other steppers, `stepper_o`,
`stepper_a`, and `stepper`, relax these restrictions).  Therefore,
sometimes we wish to restrict the behavior of the model to
deterministic, synchronous behaviors.

In PyModel, concurrency and asychrony permitted by a model program can
be removed by scenario machines, and nondeterminism can be restricted
by domains.


Restricting concurrency: synchronous scenario
---------------------------------------------

The *`synchronous`* module is a scenario machine, an FSM.  A graph of
this scenario appears in Socket/svg/synchronous_graph.svg (which you
can display in a browser).  As the graph shows, in this scenario
`send_call` is always immediately followed by `send_return`, and `recv_call`
is always immediately followed by `recv_return`.  Composing a model
program with a scenario has the effect of synchronizing them, so the
model program can only execute sequences of actions permitted by the
scenario.  Different scenarios can be written that select different
behaviors.  Here, composing the `msocket` model program with the
`synchronous` scenario machine has the effect of merging the two parts
of each split action into a single atomic (indivisible) action.  Once
`send` or `recv` is called, it always returns before another action can
begin - now the behavior is *synchronous*.  Moreover, in this scenario
one `send` is always followed by one `recv` - the behavior is
*sequential*.


Restricting nondeterminism: the nondetermistic configuration
-------------------------------------------------------------

In a model program, the enabling condition for an action might permit
a large range of argument values, but the domain for that action can
limit it to a few, or just one.  Different domains can be written that
select different collections of arguments.  The *`deterministic`* module
is a PyModel configuration file that redefines the domains of
`send_return` and `recv_return`.  Here both are *state-dependent domains*.
Now `send_return` always accepts the entire argument of `send_call` (not
just a prefix, as specified in its enabling condition), and
`recv_return` always produces the entire buffer contents (not just a
prefix).  This has the effect of deterministically transmitting the
entire message from sender to receiver in a single pair of `send`/`recv`
calls.


The test script
---------------

The test module generates some samples of behavior that demonstrate
the `msocket` model program and the effects of the `synchronous` scenario
and `deterministic` configuration.

The test module is a test script that contains test cases that run
`pmt`, the PyModel tester.  The `pmt` command generates *traces* (test
runs), which are simply sequences of actions (function calls).  The
`pmt` command can optionally execute and check the test runs it
generates, but here we just generate the traces to get samples of
behavior to examine.  For this, we do not need a stepper (test
harness) because we do not need to connect the model to any socket
implementation.

To run the script and see the traces, type this command at
the system shell prompt: trun test

The first test case executes this command: pmt -n 10 -c 6 `msocket` (you
can also type this command yourself).  It generates a short (10 to 16
step) trace from the `msocket` module alone, so the trace may exhibit
nondeterminism and asynchrony, with interleaving `send` and `recv` and
incompletely sent messages.  The messages (arguments to `send_call`) are
limited to 'a' and 'bb' by the domain in the `msocket` module.  This
command chooses actions and their arguments at random so repeating the
command generates different traces (to make runs repeatable, set the
random seed with the -s option).  To see longer traces, use a larger
-n option.  Omit the cleanup option -c to generate exactly -n steps,
which may stop in a non-accepting state (with a call in progress or a
message in flight).

The second test case executes: pmt -n 10 -c 6 synchronous msocket.
Including both the model program and a scenario machine as command
arguments forms their composition.  Now the run exhibits synchronous
behavior: each call is immediately followed by its return.  There is
no more blocking, no more interleaving of `send` and receive.  Moreover,
`send` and receive alternate, as dictated by the scenario machine.  But
the behavior may still be nondeterministic - incomplete messages may
be sent.

The third test case executes: pmt -n 10 -c 6 deterministic synchronous
socket. The also includes the `deterministic` module, the configuration
file that reassigns domains to ensure that the entire message is always
sent and received immediately.  


The `test_viewer` script
----------------------

The `test_viewer` module generates graphs that illustrate the behavior
of the `msocket` model program and the effects of the `synchronous`
scenario and `deterministic` configuration.  To generate the graphs,
type this command: trun test_viewer

The `test_viewer` module is a test script that runs `pmv`, the PyModel
viewer.  The `pmv` program in turn invokes `pma`, the PyModel analyzer,
and pmg, the PyModel graphics program, and dot, a rendering program.
The `pma` program performs an analysis called *exploration* which
generates a finite state machine (FSM) from the model, and pmg
generates a file of graphics commands in the dot language from the
FSM.  Finally, the dot program renders the output of pmg in a chosen
graphics format.  This script generates .svg files, which you can view
in a browser. (Older versions of IE did not display .svg files - has
MS fixed this?).

The `test_viewer` module generates four .svg files, which are in the
Socket/svg directory:

socketFSM.svg is generated by the command: pmv msocket.  It shows a
graph of an FSM generated by exploring the `msocket` model program.
Every node in the graph represents a program state (hover the cursor
over a node to show the state variables and their values).  Every edge
in the graph represents an action (every edge is labeled with the
function call including its argument).  Every path through this FSM
describes a trace that the model can execute --- runs generated by the
first test case in the test module are examples.  Multiple edges
emerging from a node indicate nondeterminism, and every _call edge not
immediately followed by a _return edge indicates asynchrony.

synchronous_graph.svg is generated by the command: pmv -o
synchronous_graph synchronous.  It is the graph of the synchronous
scenario machine, an FSM.

synchronousFSM.svg is generated by the command: pmv synchronous
socket.  It is a graph of the `msocket` model program composed with the
synchronous scenario machine.  Paths through this FSM include the runs
generated by the second test case in the test module.  Notice that
every call is followed by return, and every `send` is followed by receive.
But, there is still nondeterminism in action arguments.

deterministicFSM.svg is generated by the command: pmv deterministic
synchronous msocket.  It is a graph of the `msocket` model program
composed with the `synchronous` scenario machine, using the domains in
the `deterministic` module.


Stepper modules
---------------

A PyModel stepper is a test harness (sometimes called an adapter) that
connects a model (here, the `msocket` module) to a an implementation
(here, the Python standard library socket module).  A stepper enables
the PyModel tester `pmt` to use a model to call methods in the
implementation and check the results.

The PyModel Socket sample contains several steppers that demonstrate
different technques.  All of these socket steppers handle *both* ends of the
socket connection so they can test both `send` and `recv` (recall that the
model program `msocket` always sends at one end of the connection and
receives at the other).  And, they do this in a single ordinary
process (Python program invocation) on the local machine.  They
accomplish this by connecting to both ends of a socket on localhost
and interleaving calls to `send` and `recv`.

In `experiments.txt` we discuss the several steppers, in the order we wrote
them: `stepper_d` (formerly stepper), `stepper_o`, `stepper_a`, and stepper
(formerly `stepper_s`).  Each improves on its predecessors.  The last
one, stepper, is now the recommended one.  It is the only one we
discuss here.

The stepper module
------------------

(The stepper module was originally called `stepper_s`, but was renamed
to just stepper to indicate that it is now the preferred stepper
module for the socket sample.)

The stepper module supports nondeterminism and asynchrony.  

This stepper distinguishes between controllable and observable
actions.  Controllable actions can be invoked in the implementation by
the test runner `pmt` (via the stepper).  Here `send_call` and recv_call are
the controllable actions.  Observable actions cannot be invoked by the
test runner; they are generated by the implementation and passed back
to `pmt` (via stepper).  Here `send_return` and `recv_return` are the
observable actions.  The observable actions must be identified in the
model program module or a configuration module; here they are
indentified in the configuration module `observables.py`.

This stepper executes and checks test runs in this way.  First we
describe the simpler situation where the socket connection does not
block (that is, where its buffers are ready).  For each controllable
action (for example `recv_call`), the test runner `pmt` calls the action
in the `msocket` model (which may update the model state).  Then it
passes the action to this stepper, which calls the corresponding
method (s.recv) in the implementation.  Then this stepper collects the
result (data) from the implementation and constructs the corresponding
observable action (`recv_return`) where the result appears as an
argument.  Then this stepper appends this action to observation_queue,
where `pmt` can retrieve it.  Then `pmt` finds that action in the
observation queue, removes it, and checks it (including the msg
argument) with its enabling condition (`recv_return`_enabled).  If the
enabling condition returns False, the test fails.  If the enabling
condition returns True, `pmt` executes the observable action in the
model (possibly updating the model state) and the test continues.  If
the test run reaches the end and none of the actions have failed, the
test passes.

Asynchrony arises when the socket connection buffers are not ready, so
attempting to read or write at the socket would block.  In this
stepper this situation is handled by the `select` function.  (The
`stepper_a` module in this sample is similar but solves the same problem
with threads, see `experiments.txt`.).  This stepper always calls `select`
before attempting to `send` or `recv` on the socket.  The return values
from `select` indicate when the attempt would block; in those cases, the
stepper does not call `send` or `recv`, so no blocking occurs.  Instead,
this stepper simply returns None to the caller `pmt`, to indicate that
the test did not fail.  This enables `pmt` to proceed and periodically
repeat making calls to this stepper, until eventually the `select`
function might indicate that buffers are ready.

Notice that this stepper does *not* determine whether each step in the
test passes or fails, and it does not construct the message describing
the failure.  Instead, this stepper merely collects the response,
constructs and observable action, and passes it back to `pmt`.  It is
the test runner `pmt` that determines whether the test passes or fails,
and writes the message describing the failure.  This is a very
important difference between this stepper and `stepper_d` in this sample
(discussed in `experiments.txt`).  The organization used by this stepper
delegates more work to the test runner `pmt`, where it need not be
rewritten for each implementation.  It is also more general, since it
handles both nondeterminism and concurrency in the enabling conditions
for the observable actions, so it is recommended for systems that
exhibit nondeterminism and concurrency.  This style does require the
model to be written with split actions, which might be a disadvantage
for simple systems.

This stepper (or any other stepper that uses observable actions)
cannot be driven from a test suite (which specifies every action in
the test run), but can only be used for on-the-fly testing (where the
implemention generates the observable actions).


The test_stepper script
-----------------------

The `test_stepper` module is a test script that contains a single
test case that invokes a run with the stepper module.

The stepper module and `test_stepper` script are similar to
`stepper_a` and test_stepper_a -- they are all designed to handle runs
where calls to `recv` at one end of the connection can precede calls to
`send` at the other end, and where calls and returns at the two ends can
interleave.   

However, with stepper and `test_stepper` we do *not* see any test
failures like we do with `stepper_a` and test_stepper_a, where `stepper_a`
reports interleaving in an order that the model forbids, where
`recv_return` returns a message before the originating `send` returns.
Since stepper never reports this, this supports our hypothesis that
the forbidden interleaving is an artifact of the way the threads in
`stepper_a` are scheduled.  It seems that in this sample, `select` is a better
way to support asynchrony than threads.


The socket_simulator module
---------------------------

The `socket_simulator` module is a replacement for the Python standard
library socket module to use with the PyModel socket sample, to
demonstrate nondeterminism and blocking even with small messages.

The simulated socket here may nondeterministically send or receive just
part of the message, no matter how short the message (even just two
characters).

The simulated socket here blocks on `send` when the buffer is full, and
blocks on `recv` when the buffer is empty.  The buffer can be made very
small, by assigning the bufsize variable.  The default bufsize is 3
characters.

Note that this *same* socket simulator is used with `stepper_a`,
which achieves asynchrony with threads, and stepper which achieves
asynchrony with `select`.  When `stepper` imports this `socket_simulator`,
`stepper` must also import `select_simulator`.

This socket simulator can also be used with the synchronous stepper,
but it may block -- just like a real socket.

To use this simulator, just put it in the same directory with your
PyModel socket steppers and rename it (or symlink it) to `socket.py`.
The steppers will load this simulator instead of the Python standard
library socket module.  If you want to use this simulator with
stepper, you must also rename (or symlink) `select_simulator.py` to 
`select.py`.

To demonstrate the simulator, replace the standard library socket
module (as described in the previous paragraph) and execute any of the
`test_stepper` modules.

You will see that the socket behaves nondeterministically.  Now
`send_return` sometimes returns a number smaller than the length of the
msg argument to `send_call`.  For example, send_call('bb'), is sometimes
followed by send_return(1,) (not always send_return(2,)) and the
following `recv_return` often returns fewer characters than have been
sent, `'b'` not `'bb'`.  

You will also see that the simulated socket connection blocks when the
buffer is full or empty.  When the (quite small) buffer is full,
`send_call` is not immediately followed by `send_return`.  Instead,
`recv_return` must execute first, in order to free some space in the
buffer.  Likewise, `recv` blocks when the buffer is empty, and cannot
return until `send_return` leaves a message in the buffer.  If you are
using `stepper_a`, you may notice pauses when these blocks occur.  If
you are using the synchronous `stepper_d`, you may see the entire `pmt`
session block and not resume.  The only escape from this is to type
^C.

